#!/usr/bin/env python
#
#===============================================================================
#
#                           OOOO
#                         OOOOOOOO
#        PPPPPPPPPPPPP   OOO    OOO   PPPPPPPPPPPPP
#      PPPPPPPPPPPPPP   OOO      OOO   PPPPPPPPPPPPPP
#     PPP         PPP   OOO      OOO   PPP         PPP
#    PPP          PPP   OOO      OOO   PPP          PPP
#    PPP          PPP   OOO      OOO   PPP          PPP
#    PPP          PPP   OOO      OOO   PPP          PPP
#     PPP         PPP   OOO      OOO   PPP         PPP
#      PPPPPPPPPPPPPP   OOO      OOO   PPPPPPPPPPPPPP
#       PPPPPPPPPPPPP   OOO      OOO   PPP
#                 PPP   OOO      OOO   PPP
#                 PPP   OOO      OOO   PPP
#                 PPP   OOO      OOO   PPP
#                 PPP    OOO    OOO    PPP
#                 PPP     OOOOOOOO     PPP
#                PPPPP      OOOO      PPPPP
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#===============================================================================
##
# @file    rulesFunc.py
# @author  Hugh Spahr
# @date    4/19/2014
#
# @note    Open Pinball Project
# @note    Copyright 2014, Hugh Spahr
#
# @brief This are the rules functions for the simple pinball machine.  They have
#  been created from simplerules.txt, but are now modified.  Thise file should
#  eventually autogenerated from the the simplerules.txt file.

#===============================================================================

from rules.inpBitNames import InpBitNames
from rules.solBitNames import SolBitNames
from rules.ledBitNames import LedBitNames
from rules.timers import Timers
from rules.rulesData import RulesData
from rules.sounds import Sounds
from rules.sounds import BgndMusic
from rules.states import State
from gameData import GameData
from stdFuncs import StdFuncs

## Rules function class.
#
#  Contains all the rules that are specific this this set of pinball rules.
#  This will eventually be autogenerated by the parser and spit out in this
#  Python form.
class RulesFunc():
    LEFT_FLIPPER = 0x01
    RIGHT_FLIPPER = 0x02
    prev_flipper = 0
    LFT_TRGT_1 = 0x01
    LFT_TRGT_2 = 0x02
    RGHT_TRGT_1 = 0x04
    RGHT_TRGT_2 = 0x08
    TRGT_MSK = 0x0f
    curr_targets = 0
    tilted = False
    kick_retries = 0
    
    #Create stdFunc instance
    stdFuncs = StdFuncs()
    
    ## Initialize the rules class
    #
    #  Clear previous flipper
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def init(self):
        RulesFunc.prev_flipper = 0
    
    ## Process tilt input
    #
    #  Look for tilt events.  If tilted, disable solenoids and
    #  change state to tilt.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Tilt(self):
        if (StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.TILT_SWITCH)):
            StdFuncs.Disable_Solenoids(self.stdFuncs)
            GameData.gameMode = State.TILT

    ## Process flipper inputs
    #
    #  If the left flipper is pressed, rotate the inlane LEDs left.  If the right
    #  flipper is pressed, rotate the inlane LED right.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Flipper(self):
        if (StdFuncs.CheckSolBit(self.stdFuncs, SolBitNames.LFT_FLIP)):
            if ((RulesFunc.prev_flipper & self.LEFT_FLIPPER) == 0):
                StdFuncs.Led_Rot_Left(self.stdFuncs, LedBitNames.INLANE_MSK)
                GameData.inlaneLights[GameData.currPlayer] = StdFuncs.Var_Rot_Left(self.stdFuncs,  \
                    LedBitNames.INLANE_MSK, GameData.inlaneLights[GameData.currPlayer])
                RulesFunc.prev_flipper |= self.LEFT_FLIPPER
        else:
            RulesFunc.prev_flipper &= ~self.LEFT_FLIPPER
        if (StdFuncs.CheckSolBit(self.stdFuncs, SolBitNames.RGHT_FLIP)):
            if ((RulesFunc.prev_flipper & self.RIGHT_FLIPPER) == 0):
                StdFuncs.Led_Rot_Right(self.stdFuncs, LedBitNames.INLANE_MSK)
                GameData.inlaneLights[GameData.currPlayer] = StdFuncs.Var_Rot_Right(self.stdFuncs,  \
                    LedBitNames.INLANE_MSK, GameData.inlaneLights[GameData.currPlayer])
                RulesFunc.prev_flipper |= self.RIGHT_FLIPPER
        else:
            RulesFunc.prev_flipper &= ~self.RIGHT_FLIPPER

    ## Process inlane switch inputs
    #
    #  If inlane switch is closed and inlane wasn't set before, turn the LED on.
    #  If all the inlanes are complete, change state to INLANE_COMPLETE.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Inlane(self):
        if (StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.INLANE_LFT) and \
                not StdFuncs.CheckLedBit(self.stdFuncs, LedBitNames.INLANE_LFT)):
            StdFuncs.Led_On(self.stdFuncs, LedBitNames.INLANE_LFT)
            GameData.inlaneLights[GameData.currPlayer] |= LedBitNames.INLANE_LFT
        if (StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.INLANE_CTR) and \
                not StdFuncs.CheckLedBit(self.stdFuncs, LedBitNames.INLANE_CTR)):
            StdFuncs.Led_On(self.stdFuncs, LedBitNames.INLANE_CTR)
            GameData.inlaneLights[GameData.currPlayer] |= LedBitNames.INLANE_CTR
        if (StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.INLANE_RGHT) and \
                not StdFuncs.CheckLedBit(self.stdFuncs, LedBitNames.INLANE_RGHT)):
            StdFuncs.Led_On(self.stdFuncs, LedBitNames.INLANE_RGHT)
            GameData.inlaneLights[GameData.currPlayer] |= LedBitNames.INLANE_RGHT
        if (GameData.inlaneLights[GameData.currPlayer] & LedBitNames.INLANE_MSK) == LedBitNames.INLANE_MSK:
            GameData.gameMode = State.INLANE_COMPLETE

    ## Process target switch inputs
    #
    #  If target switch is closed and target wasn't set before, turn the LED on.
    #  If all the targets are complete, change state to TARGET_COMPLETE.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Targets(self):
        if StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.LFT_TRGT_1):
            StdFuncs.Led_On(self.stdFuncs, LedBitNames.LFT_TRGT_1)
            self.curr_targets |= self.LFT_TRGT_1 
        if StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.LFT_TRGT_2):
            StdFuncs.Led_On(self.stdFuncs, LedBitNames.LFT_TRGT_2)
            self.curr_targets |= self.LFT_TRGT_2 
        if StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.RGHT_TRGT_1):
            StdFuncs.Led_On(self.stdFuncs, LedBitNames.RGHT_TRGT_1)
            self.curr_targets |= self.RGHT_TRGT_1 
        if StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.RGHT_TRGT_2):
            StdFuncs.Led_On(self.stdFuncs, LedBitNames.RGHT_TRGT_2)
            self.curr_targets |= self.RGHT_TRGT_2 
        if (self.curr_targets & (self.TRGT_MSK)) == self.TRGT_MSK:
            GameData.gameMode = State.TARGETS_COMPLETE

    ## Process kickout hole
    #
    #  If the kickout hole switch is close, kick the kickout hole solenoid
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Kickout_Hole(self):
        if (StdFuncs.CheckSolBit(self.stdFuncs, SolBitNames.KICKOUT_HOLE)):
            StdFuncs.Kick(self.stdFuncs, SolBitNames.KICKOUT_HOLE)

    ## Process ball drain switch
    #
    #  Collect bonus.  Change state to END_OF_BALL.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Ball_Drain(self):
        if (StdFuncs.CheckSolBit(self.stdFuncs, SolBitNames.BALL_IN_PLAY)):
            GameData.gameMode = State.END_OF_BALL
            
    ## Process tilt initial state
    #
    #  If the kickout hole switch is set, kick that solenoid.  Start the
    #  BALL_LOCATE timer.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Tilt_Init(self):
        self.tilted = True
        if (StdFuncs.CheckSolBit(self.stdFuncs, SolBitNames.KICKOUT_HOLE)):
            StdFuncs.Kick(self.stdFuncs, SolBitNames.KICKOUT_HOLE)
            self.kick_retries = 0
            StdFuncs.Start(self.stdFuncs, Timers.KICKOUT_TIMER)
        StdFuncs.Start(self.stdFuncs, Timers.BALL_LOCATE)

    ## Process tilt normal state
    #
    #  If the ball is detected at the drain (BALL_IN_PLAY) re-enable the
    #  solenoids and switch state to END_OF_BALL.  If the kickout timer
    #  expired, check if the kicking the solenoid should be done again.
    #  If the BALL_LOCATE times out, switch to error state.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Tilt_State(self):
        if (StdFuncs.CheckSolBit(self.stdFuncs, SolBitNames.BALL_IN_PLAY)):
            StdFuncs.Enable_Solenoids(self.stdFuncs)
            GameData.gameMode = State.END_OF_BALL
        if (StdFuncs.Expired(self.stdFuncs, Timers.KICKOUT_TIMER)):
            if (StdFuncs.CheckSolBit(self.stdFuncs, SolBitNames.KICKOUT_HOLE)):
                self.kick_retries += 1
                if (self.kick_retries > 5):
                    GameData.gameMode = State.ERROR
                    print "Can't clear kickout hole"
                StdFuncs.Start(self.stdFuncs, Timers.KICKOUT_TIMER)
                StdFuncs.Kick(self.stdFuncs, SolBitNames.KICKOUT_HOLE)
        if (StdFuncs.Expired(self.stdFuncs, Timers.BALL_LOCATE)):
            GameData.gameMode = State.ERROR
            print "Lost Ball"
            
    ## Process init state
    #
    #  Disable the solenoids.  If no credits go to ATTRACT state.  If
    #  credits, go to PRESS_START_STATE
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Init(self):
        StdFuncs.Disable_Solenoids(self.stdFuncs)
        GameData.creditBallNum = GameData.credits
        if (GameData.credits == 0):
            GameData.gameMode = State.ATTRACT
        else:
            GameData.gameMode = State.PRESS_START

    ## Process add coin
    #
    #  Check if enough coins have been dropped to give a credit.  See if an
    #  extra credit is given for number of coins in a row.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Add_Coin(self):
        if StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.COIN_DROP):
            GameData.creditsInRow += 1
            GameData.partCreditsNum += 1
            if (GameData.creditsInRow == GameData.extraCredit):
                GameData.credits += 1
                if GameData.gameMode == State.PRESS_START:
                    GameData.creditBallNum = GameData.credits
                GameData.creditsInRow = 0
                GameData.partCreditsNum = 0
            if (GameData.partCreditsNum == GameData.partCreditsDenom):
                GameData.credits += 1
                if GameData.gameMode == State.PRESS_START:
                    GameData.creditBallNum = GameData.credits
                GameData.partCreditsNum = 0
        if StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.START_BTN):
            GameData.creditsInRow = 0

    ## Process start switch
    #
    #  Register the start button if no game is being played, or if the first ball is
    #  still being played.  This sets numPlayers for the game.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Press_Start(self):
        if StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.START_BTN) and (GameData.credits != 0) and \
                (GameData.ballNum == 0):
            if (GameData.numPlayers < RulesData.MAX_NUM_PLYRS):
                GameData.currPlayer = 0
                GameData.credits -= 1
                GameData.score[GameData.numPlayers] = 0
                GameData.numPlayers += 1
                GameData.creditBallNum = GameData.ballNum + 1
            GameData.gameMode = State.START_GAME
        if (GameData.gameMode == State.PRESS_START):
            StdFuncs.BlankScoreDisps(self.stdFuncs)
            StdFuncs.BlankPlyrNumDisp(self.stdFuncs)
                
    ## Process press start initialization
    #
    #  Turn off all the LEDs
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Press_Start_Init(self):
        StdFuncs.Led_Off(self.stdFuncs, LedBitNames.ALL_BITS_MSK)

    ## Process start and coin switches
    #
    #  Call Proc_Add_Coin and Proc_Press_Start
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Start_and_Coin(self):
        self.Proc_Add_Coin()
        self.Proc_Press_Start()
        
    ## Process initialize game
    #
    #  Set ball num, special level, and inlane lights to 0.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Init_Game(self):
        GameData.ballNum = 0
        GameData.specialLvl = 0
        for i in range(RulesData.MAX_NUM_PLYRS):
            GameData.inlaneLights[i] = 0
            
    ## Process start game
    #
    #  If the ball is at the plunger, or in the kickout hole, just start the game.
    #  Otherwise set state to START_BALL if ball is in drain, or ERROR if can't find
    #  the ball.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Start_Game(self):
        if StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.BALL_AT_PLUNGER) or \
                StdFuncs.CheckSolBit(self.stdFuncs, SolBitNames.KICKOUT_HOLE):
            GameData.gameMode = State.BALL_IN_PLAY
        elif StdFuncs.CheckSolBit(self.stdFuncs, SolBitNames.BALL_IN_PLAY) and \
                (GameData.gameMode == State.START_GAME):
            GameData.gameMode = State.START_BALL
        else:
            GameData.gameMode = State.ERROR
            print "Can't find ball"
             
    ## Process start ball initialize
    #
    #  Start the KICKOUT_TIMER.  Kick the BALL_IN_PLAY solenoid.  Set kick
    #  retries to 0.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Start_Ball_Init(self):
        StdFuncs.Start(self.stdFuncs, Timers.KICKOUT_TIMER)
        StdFuncs.Kick(self.stdFuncs, SolBitNames.BALL_IN_PLAY)
        GameData.kick_retries = 0
        
    ## Process start ball start
    #
    #  If the ball is at the plunger, move to BALL_IN_PLAY.  If
    #  the KICKOUT_TIMER expires, increment the kick_retries.  If less
    #  than the limit try to kick the BALL_IN_PLAY solenoid again.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Start_Ball_Start(self):
        if StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.BALL_AT_PLUNGER):
            GameData.gameMode = State.BALL_IN_PLAY
        if StdFuncs.Expired(self.stdFuncs, Timers.KICKOUT_TIMER):
            GameData.kick_retries += 1
            if (GameData.kick_retries > 5):
                GameData.gameMode = State.ERROR
                print "Ball kick failed!"
            else:
                StdFuncs.Start(self.stdFuncs, Timers.KICKOUT_TIMER)
                StdFuncs.Kick(self.stdFuncs, SolBitNames.BALL_IN_PLAY)

    ## Process ball in play initialize
    #
    #  Turn off all the inlane LEDs.  Blink the center inlane LED rapidly to indicate
    #  skill shot.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Ball_In_Play_Init(self):
        StdFuncs.Led_Off(self.stdFuncs, LedBitNames.INLANE_MSK | LedBitNames.TRGT_MSK | LedBitNames.SPECIAL)
        StdFuncs.Led_Blink_100(self.stdFuncs, LedBitNames.INLANE_CTR)
        RulesFunc.prev_flipper = 0
        GameData.targets = 0
        GameData.tilted = 0
        GameData.scoreLvl = 1
        GameData.numSpinners = 0

    ## Process ball in play start
    #
    #  If left or right inlane switch is detected, switch to NORMAL_PLAY.  If
    #  center inlane switch is detected award skill shot, play a sound, and
    #  move to NORMAL_PLAY.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Ball_In_Play_Start(self):
        if StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.INLANE_LFT):
            StdFuncs.Led_On(self.stdFuncs, LedBitNames.INLANE_LFT)
            GameData.inlaneLights[GameData.currPlayer] |= LedBitNames.INLANE_LFT
            GameData.gameMode = State.NORMAL_PLAY
        if StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.INLANE_RGHT):
            StdFuncs.Led_On(self.stdFuncs, LedBitNames.INLANE_RGHT)
            GameData.inlaneLights[GameData.currPlayer] |= LedBitNames.INLANE_RGHT
            GameData.gameMode = State.NORMAL_PLAY
        if StdFuncs.CheckInpBit(self.stdFuncs, InpBitNames.INLANE_CTR):
            StdFuncs.Led_On(self.stdFuncs, LedBitNames.INLANE_CTR)
            GameData.inlaneLights[GameData.currPlayer] |= LedBitNames.INLANE_CTR
            StdFuncs.Sounds(self.stdFuncs, Sounds.DING_DING_DING)
            print "Skill Shot"
            GameData.score[GameData.currPlayer] += 10
            GameData.gameMode = State.NORMAL_PLAY
        if GameData.gameMode == State.NORMAL_PLAY:
            StdFuncs.PlayBgnd(self.stdFuncs, BgndMusic.BGND_TRACK)
            
    ## Process normal play init
    #
    #  Grab inlane LEDs from previous ball and set them.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Normal_Play_Init(self):
        StdFuncs.Led_Set(self.stdFuncs, LedBitNames.INLANE_MSK, GameData.inlaneLights[GameData.currPlayer])
        
    ## Process normal play
    #
    #  Look for tilt, flippers, inlane completion, target completion, kickout hole,
    #  start and coin switches, and ball drains.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Normal_Play(self):
        self.Proc_Tilt()
        self.Proc_Flipper()
        self.Proc_Inlane()
        self.Proc_Targets()
        self.Proc_Kickout_Hole()
        self.Proc_Start_and_Coin()
        self.Proc_Ball_Drain()

    ## Process end of ball
    #
    #  If not tilted, process bonus.  Move to the next player or next ball appropriately.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_End_Of_Ball(self):
        if not self.tilted:
            print "Bonus %d x %d" % (GameData.scoreLvl, GameData.numSpinners)
            GameData.score[GameData.currPlayer] += (GameData.scoreLvl * GameData.numSpinners)
            StdFuncs.Wait(self.stdFuncs, 3000)
        GameData.currPlayer += 1
        if (GameData.currPlayer >= GameData.numPlayers):
            GameData.currPlayer = 0
            GameData.ballNum += 1
            if (GameData.ballNum >= RulesData.BALLS_PER_GAME):
                print "Game over"
                GameData.creditBallNum = GameData.credits
                StdFuncs.StopBgnd(self.stdFuncs);
                StdFuncs.Wait(self.stdFuncs, 3000)
                if (GameData.credits == 0):
                    GameData.gameMode = State.ATTRACT
                else:
                    GameData.gameMode = State.PRESS_START
            else:
                print "Player %d, Ball %d" % (GameData.currPlayer + 1, GameData.ballNum + 1) 
                GameData.gameMode = State.START_BALL
                GameData.creditBallNum = GameData.ballNum + 1
        else:
            print "Player %d, Ball %d" % (GameData.currPlayer + 1, GameData.ballNum + 1) 
            GameData.gameMode = State.START_BALL

    ## Process inlane complete
    #
    #  Inlane complete so increment score level.  Clear inlane lights and go back to
    #  NORMAL_PLAY.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Inlane_Comp(self):
        print "Inlanes Complete!!"
        GameData.scoreLvl += 1
        GameData.score[GameData.currPlayer] += 10
        GameData.inlaneLights[GameData.currPlayer] = 0
        StdFuncs.Led_Off(self.stdFuncs, LedBitNames.INLANE_MSK)
        GameData.gameMode = State.NORMAL_PLAY
   
    ## Process targets complete init
    #
    #  Targets complete so start blinking the special LED.  Increment special level.
    #  Start the special timer.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Targets_Comp_Init(self):
        StdFuncs.Led_Blink_100(self.stdFuncs, LedBitNames.SPECIAL)
        GameData.specialLvl += 1
        print "Bonus mult = %d" % GameData.specialLvl
        GameData.score[GameData.currPlayer] += 10
        StdFuncs.Start(self.stdFuncs, Timers.SPECIAL_TIMER)

    ## Process targets complete state
    #
    #  Give jackpot if hit kickout hole.
    #  HRS:  These rules need changed.
    #
    #  @param  self          [in]   Object reference
    #  @return None
    def Proc_Targets_Comp_State(self):
        if (StdFuncs.CheckSolBit(self.stdFuncs, SolBitNames.KICKOUT_HOLE)):
            print "Jackpot"
            GameData.score[GameData.currPlayer] += (GameData.specialLvl[GameData.currPlayer] * 100)
        if (StdFuncs.Expired(self.stdFuncs, Timers.SPECIAL_TIMER)):
            GameData.gameMode = State.NORMAL_PLAY
            self.Proc_Normal_Play()

